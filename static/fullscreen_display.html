<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Avatar Display</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        /* ì „ì²´ í™”ë©´ ë¹„ë””ì˜¤ - ì„¸ë¡œ ì˜ìƒìš© */
        #remoteVideo {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
            background-color: #000;
        }

        /* í† ìŠ¤íŠ¸ ì•Œë¦¼ ì»¨í…Œì´ë„ˆ */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 400px;
        }

        /* í† ìŠ¤íŠ¸ ì•Œë¦¼ */
        .toast {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 16px 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            animation: slideInRight 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 300px;
            border-left: 4px solid;
        }

        .toast.sequence-start {
            border-left-color: #28a745;
            background: rgba(40, 167, 69, 0.95);
            color: white;
        }

        .toast.sequence-stop {
            border-left-color: #dc3545;
            background: rgba(220, 53, 69, 0.95);
            color: white;
        }

        .toast.order {
            border-left-color: #667eea;
            background: rgba(102, 126, 234, 0.95);
            color: white;
        }

        .toast.system {
            border-left-color: #ffc107;
            background: rgba(255, 193, 7, 0.95);
            color: #000;
        }

        .toast-icon {
            font-size: 24px;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .toast-message {
            font-size: 13px;
            opacity: 0.9;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
                transform: translateX(100%);
            }
        }

        .toast.removing {
            animation: fadeOut 0.3s ease;
        }

        /* ì—°ê²° ìƒíƒœ í‘œì‹œ */
        .status-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 16px;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 999;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #dc3545;
            animation: pulse 2s ease-in-out infinite;
        }

        .status-dot.connected {
            background: #28a745;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        /* ì œí’ˆ ëª©ë¡ ìŠ¤íƒ€ì¼ */
        .product-list {
            margin-top: 4px;
            font-size: 12px;
            opacity: 0.9;
        }

        .product-item {
            margin-left: 8px;
        }
    </style>
</head>
<body>
    <!-- ì „ì²´ í™”ë©´ ë¹„ë””ì˜¤ -->
    <video id="remoteVideo" autoplay playsinline></video>

    <!-- í† ìŠ¤íŠ¸ ì•Œë¦¼ ì»¨í…Œì´ë„ˆ -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- ì—°ê²° ìƒíƒœ í‘œì‹œ -->
    <div class="status-indicator">
        <div class="status-dot" id="statusDot"></div>
        <span id="statusText">ì—°ê²° ëŒ€ê¸° ì¤‘...</span>
    </div>

    <script>
        class FullscreenDisplayClient {
            constructor() {
                this.remoteVideo = document.getElementById('remoteVideo');
                this.toastContainer = document.getElementById('toastContainer');
                this.statusDot = document.getElementById('statusDot');
                this.statusText = document.getElementById('statusText');

                // WebRTC
                this.localStream = null;
                this.pc = null;
                this.currentSessionId = null;
                this.serverUrl = 'https://unknown'; // TODO: ì‹œì‘í•˜ê¸° ì „ì— ì´ URLì„ ì‹œê·¸ë„ ì„œë²„ë¡œ êµì²´!
                this.dataChannel = null;

                this.init();
            }

            async init() {
                try {
                    // ìë™ìœ¼ë¡œ ë¯¸ë””ì–´ ì‹œì‘
                    await this.startMedia();
                    // ìë™ìœ¼ë¡œ ì„œë²„ ì—°ê²°
                    await this.connectToServer();
                } catch (error) {
                    console.error('ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                    this.showToast('system', 'ì´ˆê¸°í™” ì‹¤íŒ¨', error.message);
                }
            }

            showToast(type, title, message, duration = 5000) {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;

                const icons = {
                    'sequence-start': 'â–¶ï¸',
                    'sequence-stop': 'â¹ï¸',
                    'order': 'ğŸ›’',
                    'system': 'â„¹ï¸'
                };

                toast.innerHTML = `
                    <div class="toast-icon">${icons[type] || 'â„¹ï¸'}</div>
                    <div class="toast-content">
                        <div class="toast-title">${title}</div>
                        <div class="toast-message">${message}</div>
                    </div>
                `;

                this.toastContainer.appendChild(toast);

                // ìë™ ì œê±°
                setTimeout(() => {
                    toast.classList.add('removing');
                    setTimeout(() => toast.remove(), 300);
                }, duration);
            }

            updateStatus(text, connected = false) {
                this.statusText.textContent = text;
                if (connected) {
                    this.statusDot.classList.add('connected');
                } else {
                    this.statusDot.classList.remove('connected');
                }
            }

            async startMedia() {
                try {
                    this.updateStatus('ë¯¸ë””ì–´ ì ‘ê·¼ ì¤‘...');

                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            frameRate: { ideal: 30 }
                        },
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            channelCount: 1,
                            sampleRate: { ideal: 48000 }
                        }
                    });

                    this.updateStatus('ë¯¸ë””ì–´ ì¤€ë¹„ ì™„ë£Œ');
                } catch (error) {
                    console.error('ë¯¸ë””ì–´ ì ‘ê·¼ ì‹¤íŒ¨:', error);
                    this.showToast('system', 'ì˜¤ë¥˜', 'ì¹´ë©”ë¼/ë§ˆì´í¬ ì ‘ê·¼ ì‹¤íŒ¨');
                    throw error;
                }
            }

            async connectToServer() {
                try {
                    this.updateStatus('ì„œë²„ ì—°ê²° ì¤‘...');

                    // 1. ì„¸ì…˜ ìƒì„±
                    const sessionResponse = await fetch(`${this.serverUrl}/create-session`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (!sessionResponse.ok) {
                        throw new Error('ì„¸ì…˜ ìƒì„± ì‹¤íŒ¨');
                    }

                    const sessionData = await sessionResponse.json();
                    this.currentSessionId = sessionData.session_id;

                    console.log('ì„¸ì…˜ ìƒì„±:', this.currentSessionId);

                    // 2. WebRTC ì—°ê²°
                    this.pc = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });

                    // 3. Data Channel ìƒì„±
                    this.dataChannel = this.pc.createDataChannel('stt_channel', {
                        ordered: true
                    });

                    this.dataChannel.onopen = () => {
                        console.log('âœ… Data Channel ì—´ë¦¼');
                        this.updateStatus('ì—°ê²° ì™„ë£Œ', true);
                    };

                    this.dataChannel.onclose = () => {
                        console.log('âŒ Data Channel ë‹«í˜');
                        this.updateStatus('ì—°ê²° ëŠê¹€', false);
                    };

                    // 4. ë©”ì‹œì§€ ìˆ˜ì‹  ì²˜ë¦¬
                    this.dataChannel.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            console.log('ğŸ“© [Message]:', message);

                            // STT ë©”ì‹œì§€ëŠ” ë¬´ì‹œ
                            if (message.type === 'stt') {
                                return;
                            }

                            // sequence ë©”ì‹œì§€ ì²˜ë¦¬
                            if (message.type === 'sequence') {
                                if (message.content === 'start') {
                                    this.showToast('sequence-start', 'ëŒ€í™” ì‹œì‘', 'ìƒˆë¡œìš´ ëŒ€í™” ì‹œí€€ìŠ¤ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤');
                                } else if (message.content === 'stop') {
                                    this.showToast('sequence-stop', 'ëŒ€í™” ì¤‘ë‹¨', 'ì‹œí€€ìŠ¤ê°€ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤');
                                }
                            }

                            // order ë©”ì‹œì§€ ì²˜ë¦¬
                            if (message.type === 'order') {
                                try {
                                    const orderInfo = JSON.parse(message.content.replace(/'/g, '"'));
                                    const productsList = orderInfo.products
                                        .map(p => `<div class="product-item">â€¢ ${p.productId} x ${p.qty}</div>`)
                                        .join('');

                                    this.showToast(
                                        'order',
                                        `ì£¼ë¬¸ ì ‘ìˆ˜ (ì´ ${orderInfo.totqty}ê°œ)`,
                                        `<div class="product-list">${productsList}</div>`,
                                        7000
                                    );
                                } catch (e) {
                                    this.showToast('order', 'ì£¼ë¬¸ ì ‘ìˆ˜', message.content, 7000);
                                }
                            }

                        } catch (e) {
                            console.error('âŒ ë©”ì‹œì§€ íŒŒì‹± ì˜¤ë¥˜:', e);
                        }
                    };

                    // ICE candidate
                    this.pc.onicecandidate = async (event) => {
                        if (event.candidate) {
                            try {
                                await fetch(`${this.serverUrl}/ice-candidate`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        session_id: this.currentSessionId,
                                        candidate: event.candidate.candidate,
                                        sdpMid: event.candidate.sdpMid,
                                        sdpMLineIndex: event.candidate.sdpMLineIndex
                                    })
                                });
                            } catch (error) {
                                console.error('ICE candidate ì „ì†¡ ì‹¤íŒ¨:', error);
                            }
                        }
                    };

                    this.pc.ontrack = (event) => {
                        if (!this.remoteVideo.srcObject) {
                            this.remoteVideo.srcObject = event.streams[0];
                            console.log('ì›ê²© ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ ìˆ˜ì‹ ');
                        }
                    };

                    this.pc.onconnectionstatechange = () => {
                        console.log('ì—°ê²° ìƒíƒœ:', this.pc.connectionState);
                        switch (this.pc.connectionState) {
                            case 'connected':
                                this.updateStatus('WebRTC ì—°ê²° ì™„ë£Œ', true);
                                this.showToast('system', 'ì—°ê²° ì™„ë£Œ', 'AI ì•„ë°”íƒ€ì™€ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤');
                                break;
                            case 'failed':
                                this.updateStatus('ì—°ê²° ì‹¤íŒ¨', false);
                                this.showToast('system', 'ì—°ê²° ì‹¤íŒ¨', 'ì„œë²„ì™€ì˜ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                                break;
                            case 'disconnected':
                                this.updateStatus('ì—°ê²° ëŠê¹€', false);
                                break;
                        }
                    };

                    // 5. ë¡œì»¬ ìŠ¤íŠ¸ë¦¼ ì¶”ê°€
                    this.localStream.getTracks().forEach(track => {
                        this.pc.addTrack(track, this.localStream);
                    });

                    // 6. Offer ìƒì„±
                    const offer = await this.pc.createOffer();
                    await this.pc.setLocalDescription(offer);

                    const offerResponse = await fetch(`${this.serverUrl}/offer`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_id: this.currentSessionId,
                            sdp: offer.sdp,
                            type: offer.type
                        })
                    });

                    if (!offerResponse.ok) {
                        throw new Error('Offer ì „ì†¡ ì‹¤íŒ¨');
                    }

                    const answer = await offerResponse.json();
                    await this.pc.setRemoteDescription(new RTCSessionDescription(answer));

                    // 7. ICE candidates í´ë§
                    this.startIceCandidatePolling();

                } catch (error) {
                    console.error('ì—°ê²° ì‹¤íŒ¨:', error);
                    this.updateStatus('ì—°ê²° ì‹¤íŒ¨', false);
                    this.showToast('system', 'ì˜¤ë¥˜', `ì—°ê²° ì‹¤íŒ¨: ${error.message}`);
                }
            }

            startIceCandidatePolling() {
                const pollOnce = async () => {
                    if (!this.currentSessionId || !this.pc) {
                        return;
                    }

                    try {
                        const response = await fetch(`${this.serverUrl}/ice-candidates/${this.currentSessionId}`);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.candidates && data.candidates.length > 0) {
                                for (const candidate of data.candidates) {
                                    await this.pc.addIceCandidate(new RTCIceCandidate(candidate));
                                }
                            }
                        }

                        if (this.pc.connectionState === 'connected' || this.pc.connectionState === 'failed') {
                            return;
                        }

                        setTimeout(pollOnce, 1000);
                    } catch (error) {
                        if (this.pc && this.pc.connectionState !== 'connected' && this.pc.connectionState !== 'failed') {
                            setTimeout(pollOnce, 1000);
                        }
                    }
                };

                pollOnce();
            }
        }

        // ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Fullscreen Display Client ì´ˆê¸°í™”');
            new FullscreenDisplayClient();
        });
    </script>
</body>
</html>
